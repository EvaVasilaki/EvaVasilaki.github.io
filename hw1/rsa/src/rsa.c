#include <stdio.h>//Συμπερίληψη απαραίτητων libraries 
#include <stdlib.h>
#include <string.h>


long long int gcd(long long int x, long long int y) { //Συνάρτηση που υπολογίζει τον μέγιστο κοινό διαιρέτη 

    long long int k = x % y; //Με βάση τον αλγόριθμο του Ευκλείδη, ορίζω τη μεταβλητή k ως x mod y 
    //για να ελέγχω κάθε φορά το υπόλοιπο της διαίρεσης x/y μεχρι αυτο να γίνει 0

    if (k == 0) { //Στην περίπτωση που γίνει 0 τοτε:

        if (y<0) {//Άν ο αριθμός y είναι μικρότερος του 0 τοτε επιστρέφει τον αντίθετό του 
        //(καθώς ψάχνω τον ΜΚΔ, το προσιμο δεν παίζει ρόλο στη διαίρεση και επομένως εάν ενας αριθμος διαιρείται με το -y τοτε θα διαιρείται και με το y) 
        return (-1)*y; //Φροντίζοντας έτσι ο ΜΚΔ να είναι πάντα θετικός
        }
        else {//Aν είναι θετικός
            return y;//Επιστροφή του y
        }
    }

    else return gcd(y,k);//Εαν το k δεν ισουται με 0, τοτε μεσω της αναδρομής, επαναλαμβάνεται η συνάρτηση ως gcd(y,k) οπου k το υπόλοιπο που υπολογίζεται

}


long long int phi(long long int n)//Totient function του Euler: Υπολογίζει το πλήθως των αριθμών που είναι coprime με το n
{
    long long int result = n; //Ορίζω το αποτέλεσμα να ισουται με το n

    for (long long int p = 2; p * p <= n; ++p) {//Έλεγχος πηλίκου της διαίρεσης n / p εως το p να φτάσει στο sqrt(n)

        if (n % p == 0) {//Αν το p είναι διαιρέτης του n τοτε το αποτέλεσμα μεταβάλλεται καθώς τοτε δεν θα είναι σχετικά πρώτος με το n
            
            while (n % p == 0)//Οσο το p είναι διαιρέτης του n
                n /= p;// μεταβάλλεται η δύναμη n .To n θα ισουται με n/p ώστε να φτάσει σε αριθμό που δεν είναι πλέον διαιρέτης του n

            result *= (1.0 - (1.0 / (float)p));//Ενημέρωση του αποτελέσματος έτσι ώστε με τον πολλαπλασιασμό του (1.0 - 1/p) μειώνεται το άθρισμα των αριθμών που 
            //ειναι σχετικά πρώτοι με τον n  κατα το σύνολο των αριθμων που διαιρούνται απο το p
        }
    }

    if (n > 1)//Αν ο αριθμος n είναι μεγαλύτερος του 1 τότε
        result -= result / n;// σημαίνει οτι ο n είναι πρώτος που λαμβάνεται υπόψην στη τελική τιμή του phi(n). Τοτε ενημερώνεται το αποτέλεσμα. Η παράσταση  result -= result / n αφαιρεί το ποσοστό των αριθμών που είναι
        //πολλαπλάσια του n από την αρχική τιμή του result

    //επιστροφη του τελικου αποτελέσματος
    return result;
}

int prime(long long int x) {//Έλεγχος πρωταρχικότητας 

    if (x <= 1) return 0; //Για x=1 δεν είναι πρώτος
    if (x == 2) return 1; //Για x=2 ειναι πρώτος
    if (x % 2 == 0) return 0; //Για x που διαιρείται με το 2 δεν είναι πρωτος

    for (long long int j = 3; j * j <= x; j += 2) {//Αφετηρια από τον αριθμό 3 έως τον αριθμος sqrt(x) με βήμα +2 ωστε να προσπερνά τους ζυγούς αριθμους
        //καθώς εαν διαιρείται με ζυγό αριθμό τοτε θα διαιρείται και με το 2 άρα δεν θα είναι πρωτος
        if (x % j == 0) return 0;//Αν διαιρείται με κάποιον αριθμό στο διάστημα 3<=j<=sqrt(x) τοτε δεν είναι πρώτος και το πρόγραμμα επιστρέφει 0
    }
    return 1;//Αν είναι πρώτος τοτε το πρόγραμμα επιστρέφει 1
}

long long int coprime(long long int x, long long int N) {//Έλεγχος σχετικης πρωταρχικότητας μεταξύ δύο αριθμών 

    long long int k = phi(N);//Ορισμός της μεταβλητής k να ισούται με το phi(N)
    return gcd(x, k)==1; //Επιστροφή του ΜΚΔ του x και του phi(N) να ισούται με 1. Αν δεν ισούται με 1 τότε οι αριθμοί δεν είναι coprime μεταξύ τους
}


long long int reverseCheck (long long int e, long long int d, long long int N) {//Ελεγχος για αντίστροφους 

    long long int k = phi(N);//Ορισμος της μεταβλητής k ως το phi(N)
    return (e*d)%k==1;//Eπιστροφή της πρότασης να ισούται με 1. Αν δεν ισουται με 1 τοτε οι αριθμοί δεν ειναι αντίστροφοι
}

long long int exponentMod(long long int x, long long int n, long long int m) {//Modular exponentiation
 
    long long int result = 1;  //Ορισμός του result να ισούται με 1 ώστε να μην αλλαζει η τιμή του αποτελέσματος στον πολλαπλασιασμό
    x = x % m; //Ορισμός του x να ισουται με το x mod m ώστε να εξασφαλιστεί οτι x<m              

    while (n > 0) {//Επανάληψη μέχρι να μηδενιστεί η δύναμη n
      
        if (n % 2 == 1) {//Περίπτωση που η δύναμη n είναι μονός αριθμός
            result = (result * x) % m;// Ενημέρωση του result με το γινόμενο του προηγούμενου αποτελέσματος και του 
        //x, και στη συνέχεια χρησιμοποιείται το υπόλοιπο με το m για την αποφυγη μεγάλων αριθμών
        }

        x = (x * x) % m;//Τετραγωνισμός του x και υπολογισμός του mod m. Ο λόγος για τον οποίο τετραγωνίζουμε το x είναι ότι, αν έχουμε ήδη υπολογίσει το (x^k)mod m τότε το 
        //(x^2k)mod m μπορεί να υπολογιστεί με τετραγωνισμό του (x^k)mod m το οποίο επιτρέπει την ταχύτερη αύξηση της δύναμης.
        n = n / 2;//Η δύναμη n διαιρείται διαρκώς με το 2. Αυτό μειώνει τη δύναμη κατά το ήμισυ σε κάθε επανάληψη. Επειδή χρησιμοποιείται τετραγωνισμός, μειώνεται η δύναμη κατά το ήμισυ σε κάθε βήμα
    }

    return result;//Επιστροφή αποτελέσματος 
}


long long int encrypt (long long int m, long long int e, long long int N) {//Συνάρτηση για κρυπτογράφηση του μηνύματος
    return exponentMod(m, e, N);//Επιστροφη κρυπτογραφημένου μηνύματος με χρήση της exponentMod
}

long long int decrypt (long long int m, long long int d, long long int N) {//Συνάρτηση για αποκρυπτογράφηση του μηνύματος
    return exponentMod(m, d, N);//Επιστροφή αποκρυπτογραφημένου μηνύματος με κλήση της exponentMod
}

int main(int argc, char ** argv) {

    //Έλεγχος : ο αριθμός των argument στο τερματικό πρέπει να ισούται με 6
    if (argc != 6) {
        printf("Usage: ./rsa enc|dec <exp_exp> <priv_exp> <prime1> <prime2>\n");//Σωστή κλήση του προγράμματος
        return 1;//Exit code 1 για λανθασμενη κλήση του προγράμματος
    }

    //Ορισμός των μεταβλητών ως τα ορίσματα που δίνονται στην ανάλογη θέση απο το terminal
    long long int e = atoll(argv[2]);
    long long int d = atoll(argv[3]);
    long long int p = atoll(argv[4]);
    long long int q = atoll(argv[5]);
    //Ορισμός της μεταβλητής N ως το γινόμενο των p και q
    long long int N = p*q;
        

    //Περιορισμός : το πρώτο argument πρεπει να είναι είτε "enc" είτε "dec"
    if(strcmp(argv[1], "dec") != 0 && strcmp(argv[1], "enc") != 0) {//Χρήση της συνάρτησης strcmp για τη σύγκρηση μεταξύ δύο συμβολοσειρών
        printf("First argument must be 'enc' or 'dec'\n");//Μήνυμα σε περιπτώση λανθασμένης εισόδου
        return 1;//Exit code 1
    }

    //Περιορισμός: όλοι οι ακέραιοι πρέπει να είναι θετικοί.
    if(e<0 || d<0 || p<0 || q<0) {
        printf("Negative numbers are not allowed\n");//Μήνυμα λανθασμένης εισόδου
        return 1;//Exit code 1
    }
        
    //Περιορισμός: οι ακέραιοι p και q είναι πρώτοι
    if (!prime(p) || !prime(q)) {//Αν οι συναρτήσεις δεν ισχύουν τότε 
        printf("p and q must be prime\n");//Μήνυμα λανθασμένης εισόδου
        return 1;//Exit code 1
    }

    // Περιορισμός: ο ακέραιος e είναι coprime με το ϕ(N).
    if (!coprime(e, N)) {
        printf("e is not coprime with phi(N)\n");//Μήνυμα λανθασμένης εισόδου
        return 1;//Exit code 1
    }
        
    //Περιορισμός: οι ακέραιοι e και d είναι αντίστροφοι
    if(!reverseCheck(e, d, N)) {
        printf("e * d mod phi(N) is not 1\n");//Μήνυμα λανθασμένης εισόδου
        return 1;//Exit code 1
    }

    //Ορισμός μυστικού μηνύματος m
    long long int m = 0;

    //Έλεγχος: Αν η είσοδος της scanf είναι λανθασμένη το πρόγραμμα τερματίζει με exit code 1
    if(scanf("%lld" , &m)!= 1) { //Ανάγνωση της τιμής του m από το τερματικό 
        return 1; //Exit code 1
    }
        
    //Περιορισμός: το μήνυμα m πρέπει να είναι θετικό
    if(m<0){ 
        printf("Negative numbers are not allowed\n");//Μήνυμα λανθασμένης εισόδου
        return 1;//Exit code 1
    }
    //Περιορισμός: το μήνυμα m πρέπει να είναι μικρότερο του Ν
    if (N < m) {
        printf("Message is larger than N\n");//Μήνυμα λανθασμένης εισόδου
        return 1;//Exit code 1
    }


    //Ορισμός μεταβλητής εξόδου
    long long int output;
    //Επιλογή του προγράμματος ανάλογα του πρώτου argument απο το τερματικό για κρυπτογράφηση ή αποκρυπτογράφηση
    //Εάν το argument στη θεση 1 ισούται με enc τότε το πρόγραμμα χρησιμοποιεί τη συναρτηση encrypt και αποθηκεύει το αποτέλεσμά της στη μεταβλητή output
    if (strcmp(argv[1], "enc") == 0) {
        output = encrypt(m, e, N);
    //Εάν το argument στη θεση 1 ισούται με dec τότε το πρόγραμμα χρησιμοποιεί τη συναρτηση decrypt και αποθηκεύει το αποτέλεσμά της στη μεταβλητή output 
    } else if (strcmp(argv[1], "dec") == 0) {
        output = decrypt(m, d, N);
    }

    //Εκτύπωση του αποτελέσματος
    printf("%lld\n" ,output);
        
    //Exit code 0 σωστή έξοδος του προγράμματος
    return 0;

    }  
    
